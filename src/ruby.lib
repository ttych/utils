#!/bin/sh
# -*- mode: sh -*-

#%toolsh_dir%
#%toolsh_file%

########## clean
gem_clean()
{
    if [ -n "$GEM_HOME" ]; then
        unset GEM_HOME || echo >&2 "cannot reset GEM_HOME"
    fi
    if [ -n "$GEM_PATH" ]; then
        unset GEM_PATH || echo >&2 "cannot reset GEM_PATH"
    fi
}

gem_clean


########## rbenv
# RBENV_INSTALL_RUBY_VERSION="${RBENV_INSTALL_RUBY_VERSION:-2.4.3}"
# RBENV_INSTALL_REPO_BASE="${RBENV_INSTALL_REPO_BASE:-https://github.com/rbenv}"
# RBENV_INSTALL_REPO_NAME="${RBENV_INSTALL_REPO_NAME:-rbenv}"
# RBENV_INSTALL_REPO_PLUGINS="${RBENV_INSTALL_REPO_PLUGIN_NAMES:-ruby-build rbenv-vars}"

# RBENV_INSTALL_TMPDIR=
# for tmp_dir in "$HOME/tmp" /local /var/tmp; do
#     touch $tmp_dir/test.$$ \
#         && rm -f $tmp_dir/test.$$ \
#         && RBENV_INSTALL_TMPDIR="$tmp_dir" \
#         && break
# done

# RBENV_INSTALL_PATH="${1}"
# RBENV_INSTALL_PATH="${RBENV_INSTALL_PATH:-$(rbenv root 2>/dev/null)}"
# RBENV_INSTALL_PATH="${RBENV_INSTALL_PATH:-$RBENV_ROOT}"
# RBENV_INSTALL_PATH="${RBENV_INSTALL_PATH:-$HOME/.rbenv}"


# clone_or_update()
# {
#     clone_or_update__source="$1"
#     clone_or_update__target="$2"
#     [ -z "$clone_or_update__source" ] && return 1
#     [ -z "$clone_or_update__target" ] && return 1

#     # clone
#     cd "${clone_or_update__target}" 2>/dev/null || mkdir -p "${clone_or_update__target}" || return 1
#     [ -d "$clone_or_update__target/.git" ] ||
#         git clone -q "${clone_or_update__source}.git" "${clone_or_update__target}" ||
#         return 1

#     # update
#     cd "${clone_or_update__target}" && git pull -q || \
#             return 1
# }

# rbenv_profile()
# {
#     cat <<EOF
# # rbenv profile
# RBENV_ROOT="$RBENV_INSTALL_PATH" ; export RBENV_ROOT
# PATH=\$RBENV_ROOT/bin:\$PATH ; export PATH
# eval "\$(rbenv init -)"
# EOF
# }


# set -e
# # install rbenv
# clone_or_update "$RBENV_INSTALL_REPO_BASE/$RBENV_INSTALL_REPO_NAME" \
#                 "$RBENV_INSTALL_PATH"

# # install plugins
# mkdir -p "$RBENV_INSTALL_PATH/plugins"
# for plugin in $RBENV_INSTALL_REPO_PLUGINS; do
#     clone_or_update "$RBENV_INSTALL_REPO_BASE/$plugin" \
#                     "$RBENV_INSTALL_PATH/plugins/$plugin"
# done

# # profile
# rbenv_profile
# eval "$(rbenv_profile)"

# # install ruby
# [ -n "$RBENV_INSTALL_TMPDIR" ] && RBENV_BUILD_ROOT="$RBENV_INSTALL_TMPDIR"
# rbenv install -s "$RBENV_INSTALL_RUBY_VERSION"
# rbenv global "$RBENV_INSTALL_RUBY_VERSION"

# # install bundler
# gem install bundler

rbenv_load()
{
    RBENV_ROOT="${1:-$HOME/.rbenv}"
    export RBENV_ROOT
    PATH="$RBENV_ROOT/bin:$PATH"
    export PATH
    eval "$(rbenv init -)"
    [ -r "$RBENV_ROOT/completions/rbenv.${SHELL_SHORT}" ] && . "$RBENV_ROOT/completions/rbenv.${SHELL_SHORT}"
}

########## rvm
rvm_load()
{
    source "${1:-$HOME/.rvm/scripts/rvm}"
}

ruby_env()
{
    for _RUBY_HOME in "${HOME_ALT}" "${HOME}"; do
        _RUBY_RBENV_AVAILABLE=false
        _RUBY_RBENV_ROOT="$_RUBY_HOME/.rbenv"
        ( cd "$_RUBY_RBENV_ROOT" 2>/dev/null ) && [ -x "$_RUBY_RBENV_ROOT/bin/rbenv" ] && _RUBY_RBENV_AVAILABLE=true

        _RUBY_RVM_AVAILABLE=false
        _RUBY_RVM_ROOT="$_RUBY_HOME/.rvm"
        ( cd "$_RUBY_RVM_ROOT" 2>/dev/null ) && [ -x "$_RUBY_RVM_ROOT/scripts/rvm" ] && _RUBY_RVM_AVAILABLE=true


        if $_RUBY_RBENV_AVAILABLE; then
            rbenv_load "$_RUBY_RBENV_ROOT"
            break
        elif $_RUBY_RVM_AVAILABLE; then
            rvm_load "$_RUBY_RVM_ROOT"
            break
        fi
    done
}

ruby_env




_RUBY_FILE_EXT='rb gemspec'

is_ruby_file()
{
    for is_ruby_file__ext in $_RUBY_FILE_EXT; do
        case "$1" in
            *.$is_ruby_file__ext) return 0;;
        esac
    done
    return 1
}



_RUBY_LIST_TEST_FRAMEWORKS='rspec minitest'



_RUBY_LIST_QUALITY_GEMS='rubocop reek cane flay flog roodi sandi_meter laser
                 debt_ceiling
                 heckle churn
                 brakeman bullet
                 coveralls
                 rubycritic
                 simplecov simplecov-html
                 metric_fu'

# rubocop      : Ruby static code analyzer, based on the community Ruby style guide.
# reek         : Detects code smells like coupling, clumping, large areas, short names.
# cane         : Code quality threshold checking as part of your build.
# flay         : Analyzes code for structural similarities to find areas for refactoring.
# flog         : Scores an ABC complexity metric: Assignments, Branches, Calls.
# roodi        : Ruby Object Oriented Design Inferometer: parses code to warn on design issues.
# sandi_meter  : Static analysis tool for checking Ruby code for Sandi Metz' rules.
# laser        : LASER: Lexically- and Semantically-Enriched Ruby bug detector.

# debt_ceiling : Scores a technical debt metric and manages debt reduction.

# heckle       : Perturbs our tests to ensure they are working correctly.
# churn        : Detects code that changes often for us to review, refactor, retest.

# brakeman     : Detects security vulnerabilities in Rails apps via static analysis.
# bullet       : Detects database N+1 queries, unused eager loading, and counter cache needs.
# rails_best_practices : parse codes in vendor, spec, test and features directories. [Retired; less-maintained]

# coveralls    : Web service to track code coverage over time.

# rubycritic   : Reporter that wraps gems such as Reek, Flay and Flog.

# simplecov           : Code coverage analyzer for Ruby 1.9+
# simplecov-html      : HTML output formatter for SimpleCov.
# simplecov-rcov-text : Text output formatter for SimpleCov. [Outdated]

# metrical     : Executes MetricFu separate from your project's dependencies. [requires newer metric_fu]
# metric_fu    : Meta-analytics that runs churn, reek, roodi, etc. and graphs results.



ruby_script_base()
{
    cat <<EOF
#!/usr/bin/env ruby
# -*- mode: ruby -*-

EOF
}








#%require% std.lib
#%require% dev.lib
#%require% terminal.lib
#%require% file.lib
#%require% git_scm.lib







ruby_script_init()
{
    [ $# -ne 1 ] && return 1
    ruby_script_base > "$1"
}

ruby_script_name()
{
    ruby_script_name="$1.rb"
}


ruby_file_tag()
{
    ruby_file_tag=
    case "$1" in
        *_spec.rb) ruby_file_tag=rspec ;;
        *_test.rb) ruby_file_tag=minitest ;;
        *.rb)      ruby_file_tag=source ;;
        *.gemspec) ruby_file_tag=ruby ;;
    esac
}

ruby_guard()
{
    file_mon -c 'ruby_rgr "%s"' "$@"
}

ruby_rubocop()
{
    which rubocop 2>/dev/null >/dev/null || return 0
    rubocop -f fu -R "$1"
}

ruby_reek()
{
    which reek 2>/dev/null >/dev/null || return 0
    reek "$1"
}

ruby_gemfile_env()
{
    ruby_gemfile_env=
    [ -r 'Gemfile' ] || return 1
    ruby_gemfile_env='bundle exec'
}

ruby_rake_env()
{
    ruby_rake_env=
    [ -r 'Rakefile' ] || return 1
    ruby_rake_env=rake
}

ruby_rspec()
{
    ruby_gemfile_env
    $ruby_gemfile_env rspec "$1"
}

ruby_rspec_all()
{
    ruby_gemfile_env
    $ruby_gemfile_env rspec
}

ruby_minitest()
{
    ruby_gemfile_env
    ruby_rake_env

    ruby_minitest__rake="${ruby_rake_env:+$ruby_rake_env test}"
    ruby_minitest__cmd="${ruby_minitest__rake:-ruby}"
    ruby_minitest__arg="${ruby_rake_env:+TEST=}"
    ruby_minitest__arg="${ruby_minitest__arg}$1"

    $ruby_gemfile_env $ruby_minitest__cmd $ruby_minitest__arg
}

ruby_minitest_all()
{
    ruby_gemfile_env
    ruby_rake_env

    [ -z "$ruby_rake_env" ] && return 0

    $ruby_gemfile_env $ruby_rake_env test
}

ruby_rgr()
{
    [ -r "$1" ] || return 1

    ruby_rgr__verbose=true
    if [ "$1" = '-q' ]; then
        shift
        ruby_rgr__verbose=false
    fi
    ruby_file_tag "${1}"
    [ -z "$ruby_file_tag" ] && return 1
    ruby_rgr__status=0
    ruby_rgr__file="${1#\./}"

    $ruby_rgr__verbose && \
        ruby_rgr_title "$ruby_rgr__file changed: $ruby_file_tag / `date '+%Y-%m-%d %H:%M:%S'`"

    ruby_rgr_test "$ruby_rgr__file" "$ruby_file_tag" && \
        ruby_rgr_rubocop "$ruby_rgr__file" && \
        ruby_rgr_reek "$ruby_rgr__file" && \
        ruby_rgr_stage "$ruby_rgr__file" || \
            ruby_rgr__status=1

    if [ $ruby_rgr__status -eq 0 ]; then
        ruby_rgr__status_msg=OK
    else
        ruby_rgr__status_msg=FAILED
    fi

    $ruby_rgr__verbose && \
        ruby_rgr_title "$ruby_rgr__file end: $ruby_rgr__status_msg / `date '+%Y-%m-%d %H:%M:%S'`"

    return $ruby_rgr__status
}

ruby_rgr_test()
{
    case "$2" in
        source|rspec|minitest) ;;
        *) return 0 ;;
    esac

    if [ "$2" = 'source' ]; then
        ruby_test_find "$1"
        ruby_rgr_test__file="$ruby_test_find__file"
        ruby_rgr_test__type="$ruby_test_find__type"
    else
        ruby_rgr_test__file="$1"
        ruby_rgr_test__type="$2"
    fi

    if [ -z "$ruby_rgr_test__file" ]; then
        $ruby_rgr__verbose && \
            ruby_rgr_subtitle "test not found for $2 $1"
        return 1
    fi

    ruby_rgr_test_one "${ruby_rgr_test__type}" "$ruby_rgr_test__file" && \
        ruby_rgr_test_all "${ruby_rgr_test__type}"
}

ruby_rgr_test_one()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "test : $2($1)"
    ruby_${ruby_rgr_test__type} "$ruby_rgr_test__file"
}

ruby_rgr_test_all()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "test : all($1)"
    ruby_${ruby_rgr_test__type}_all
}

ruby_rgr_rubocop()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "rubocop : $1"
    ruby_rubocop "$1"
}

ruby_rgr_reek()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "reek : $1"
    ruby_reek "$1"
}

ruby_rgr_stage()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "git stage : $1"
    git_scm_add "$1"
}

ruby_rgr_title()
{
    terminal_set_attr 0  $TERMINAL_BOLD
    #terminal_set_fg $TERMINAL_CYAN
    terminal_set_fg $TERMINAL_YELLOW
    printf "|>>> %s <<<|\n" "$@"
    terminal_set_fg ''
}

ruby_rgr_subtitle()
{
    terminal_set_attr 0  $TERMINAL_BOLD
    #terminal_set_fg $TERMINAL_CYAN
    terminal_set_fg $TERMINAL_YELLOW
    printf "|  > %s <  |\n" "$@"
    terminal_set_fg ''
}

ruby_test_find()
{
    ruby_test_find__file=
    ruby_test_find__type=
    for ruby_test_find__t in $RUBY_TEST_FRAMEWORKS; do
        if ruby_${ruby_test_find__t}_find "$1"; then
            eval ruby_test_find__file=\$ruby_${ruby_test_find__t}_find
            ruby_test_find__type=$ruby_test_find__t
            break
        fi
    done
}

ruby_minitest_find()
{
    ruby_minitest_find="${1%.rb}_test.rb"

    [ -r "${ruby_minitest_find}" ] && return 0

    ruby_minitest_find="test/${ruby_minitest_find#*/}"
    [ -r "$ruby_minitest_find" ]
}

ruby_rspec_find()
{
    ruby_rspec_find="${1%.rb}_spec.rb"

    [ -r "${ruby_rspec_find}" ] && return 0

    ruby_rspec_find="spec/${ruby_rspec_find#*/}"
    [ -r "$ruby_rspec_find" ]
}

ruby_gem_install()
{
    for ruby_gem_install__g in $RUBY_QUALITY_GEMS; do
        terminal_set_fg $TERMINAL_YELLOW
        echo gem install $ruby_gem_install__g
        terminal_set_fg ''
        gem install -q $ruby_gem_install__g
    done
}


###############################################################################
# init suite
###############################################################################

ruby_init_list()
{
    echo 'ruby_init actions are :'
    grep '^ruby_init_[a-z_]*()' "$TOOLSH_FILE" | \
        while read ruby_init_list__action; do
            ruby_init_list__action="${ruby_init_list__action#ruby_init_}"
            ruby_init_list__action="${ruby_init_list__action%()}"
            printf " %s\n" "$ruby_init_list__action"
        done
}

ruby_init()
{
    if [ -z "$1" ]; then
        ruby_init_list
        return 0
    fi
    ruby_init="$1" ; shift
    ruby_init_"${ruby_init}" "$@"
}

ruby_init_kata()
{
    ruby_init_kata_gemfile "$@"   || return 1
    ruby_init_kata_rakefile "$@"  || return 1
    ruby_init_kata_guardfile "$@" || return 1
    ruby_init_gitignore "$@" || return 1
}

_ruby_init_opts()
{
    _ruby_init_opts=
    _ruby_init_opts__force=FALSE

    OPTIND=1
    while getopts :f _ruby_init_opts__opt; do
        case $_ruby_init_opts__opt in
            f) _ruby_init_opts="${_ruby_init_opts} -f"
               _ruby_init_opts__force=TRUE ;;
        esac
    done
    _ruby_init_opts__index=$(($OPTIND - 1))
}

_ruby_init_cd()
{
    _ruby_init_cd="${1:-.}"
    cd "$_ruby_init_cd" || return 1
    _ruby_init_cd="$PWD"
    if [ -d "ruby" ]; then
        cd "ruby" || return 1
        _ruby_init_cd="$_ruby_init_cd/ruby/"
    fi
}

_ruby_init_copy()
{
    [ -z "$1" ] && return 1
    [ -z "$2" ] && return 1

    if [ -r "$2" ]; then
        echo "Diff from $2 to $1"
        diff "$2" "$1"
        echo
    fi

    cp "$1" "$2" || return 1
    if git_is_inside_work_tree; then
        git add "$2"
    fi
}

ruby_init_kata_gemfile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/Gemfile_kata" \
                    'Gemfile'

    bundle || return 1
)

ruby_init_kata_rakefile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/Rakefile_kata" \
                    'Rakefile'
)

ruby_init_kata_guardfile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    ruby_init_kata_guardfile__source=
    if [ -d 'spec' ] || [ -d 'test' ]; then
        [ -d 'test' ] &&
            ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_test"
        [ -d 'spec' ] &&
            ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_spec"
    else
        ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_test"
    fi

    _ruby_init_copy "$ruby_init_kata_guardfile__source" \
                    'Guardfile'
)

ruby_init_gitignore()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/gitignore_ruby" \
                    '.gitignore'
)
