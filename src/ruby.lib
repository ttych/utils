#!/bin/sh
# -*- mode: sh -*-

#%toolsh_dir%
#%toolsh_file%

#%require% git_scm.lib



_RUBY_TMPDIR="${_RUBY_TMPDIR:-$_TMPDIR}"
_RUBY_TMPDIR="${_RUBY_TMPDIR:-/tmp}"

_RUBY_DEFAULT_VERSION=2.5.3
_RUBY_FILE_EXT='rb gemspec'
_RUBY_TEST_FRAMEWORKS='rspec minitest'

_RUBY_QUALITY_GEMS='rubocop
                    reek
                    cane
                    flay
                    flog
                    roodi
                    sandi_meter
                    laser
                    debt_ceiling
                    heckle
                    churn
                    brakeman
                    bullet
                    coveralls
                    rubycritic
                    simplecov
                    simplecov-html
                    metric_fu'
# rubocop      : Ruby static code analyzer, based on the community Ruby style guide.
# reek         : Detects code smells like coupling, clumping, large areas, short names.
# cane         : Code quality threshold checking as part of your build.
# flay         : Analyzes code for structural similarities to find areas for refactoring.
# flog         : Scores an ABC complexity metric: Assignments, Branches, Calls.
# roodi        : Ruby Object Oriented Design Inferometer: parses code to warn on design issues.
# sandi_meter  : Static analysis tool for checking Ruby code for Sandi Metz' rules.
# laser        : LASER: Lexically- and Semantically-Enriched Ruby bug detector.
# debt_ceiling : Scores a technical debt metric and manages debt reduction.
# heckle       : Perturbs our tests to ensure they are working correctly.
# churn        : Detects code that changes often for us to review, refactor, retest.
# brakeman     : Detects security vulnerabilities in Rails apps via static analysis.
# bullet       : Detects database N+1 queries, unused eager loading, and counter cache needs.
# rails_best_practices : parse codes in vendor, spec, test and features directories. [Retired; less-maintained]
# coveralls    : Web service to track code coverage over time.
# rubycritic   : Reporter that wraps gems such as Reek, Flay and Flog.
# simplecov           : Code coverage analyzer for Ruby 1.9+
# simplecov-html      : HTML output formatter for SimpleCov.
# simplecov-rcov-text : Text output formatter for SimpleCov. [Outdated]
# metrical     : Executes MetricFu separate from your project's dependencies. [requires newer metric_fu]
# metric_fu    : Meta-analytics that runs churn, reek, roodi, etc. and graphs results.



########## clean
gem_clean()
{
    if [ -n "$GEM_HOME" ]; then
        unset GEM_HOME || echo >&2 "cannot reset GEM_HOME"
    fi
    if [ -n "$GEM_PATH" ]; then
        unset GEM_PATH || echo >&2 "cannot reset GEM_PATH"
    fi
}

gem_clean


########## rbenv
RBENV_REPO_ORGA="${RBENV_REPO_ORGA:-https://github.com/rbenv}"
RBENV_REPO_NAME="${RBENV_REPO_NAME:-rbenv}"
RBENV_PLUGINS="${RBENV_PLUGINS:-ruby-build rbenv-vars}"


rbenv_guess_path()
{
    rbenv_guess_path="${1}"
    rbenv_guess_path="${rbenv_guess_path:-$(rbenv root 2>/dev/null)}"
    rbenv_guess_path="${rbenv_guess_path:-$RBENV_ROOT}"
    rbenv_guess_path="${rbenv_guess_path:-$HOME/.rbenv}"
}

rbenv_install()
{
    rbenv_guess_path "$1"
    rbenv_install__path="$rbenv_guess_path"

    rbenv_install_base "$rbenv_install__path" &&
        rbenv_install_plugins "$rbenv_install__path" &&
        rbenv_load "$rbenv_install__path" &&
        rbenv_install_ruby &&
        rbenv_install_bundler
}

rbenv_install_base()
{
    rbenv_guess_path "$1"
    rbenv_install_base__path="$rbenv_guess_path"

    _git_clone_or_update "$RBENV_REPO_ORGA/$RBENV_REPO_NAME" "$rbenv_install_base__path"
}

rbenv_install_plugins()
{
    rbenv_guess_path "$1"
    rbenv_install_plugins__path="$rbenv_guess_path"

    mkdir -p "$rbenv_install_plugins__path/plugins"
    for rbenv_install_plugins__p in $RBENV_PLUGINS; do
        _git_clone_or_update "$RBENV_REPO_ORGA/$rbenv_install_plugins__p" \
                             "$rbenv_install_plugins__path/plugins/$rbenv_install_plugins__p"
    done
}

rbenv_install_ruby()
{
    rbenv_install_ruby__version="${1:-$_RUBY_DEFAULT_VERSION}"
    [ -n "$_RUBY_TMPDIR" ] && RBENV_BUILD_ROOT="$_RUBY_TMPDIR"
    rbenv install -s "$rbenv_install_ruby__version"
    rbenv_install_ruby__global=$(rbenv global)
    [ -z "$rbenv_install_ruby__global" ] &&
        rbenv global "$rbenv_install_ruby__version"
}

rbenv_install_bundler()
{
    gem install bundler
}

rbenv_update()
{
    rbenv_guess_path "$1"
    rbenv_update__path="$rbenv_guess_path"

    rbenv_install_base "$rbenv_update__path" &&
        rbenv_install_plugins "$rbenv_update__path"
}

rbenv_load()
{
    rbenv_guess_path "$1"
    RBENV_ROOT="$rbenv_guess_path"
    export RBENV_ROOT
    PATH="$RBENV_ROOT/bin:$PATH"
    export PATH
    eval "$(rbenv init -)"
    #[ -r "$RBENV_ROOT/completions/rbenv.${SHELL_SHORT}" ] &&
    #    . "$RBENV_ROOT/completions/rbenv.${SHELL_SHORT}"
}

########## rvm
rvm_load()
{
    source "${1:-$HOME/.rvm/scripts/rvm}"
}

ruby_env()
{
    for _RUBY_HOME in "${HOME_ALT}" "${HOME}"; do
        _RUBY_RBENV_AVAILABLE=false
        _RUBY_RBENV_ROOT="$_RUBY_HOME/.rbenv"
        ( cd "$_RUBY_RBENV_ROOT" 2>/dev/null ) && [ -x "$_RUBY_RBENV_ROOT/bin/rbenv" ] && _RUBY_RBENV_AVAILABLE=true

        _RUBY_RVM_AVAILABLE=false
        _RUBY_RVM_ROOT="$_RUBY_HOME/.rvm"
        ( cd "$_RUBY_RVM_ROOT" 2>/dev/null ) && [ -x "$_RUBY_RVM_ROOT/scripts/rvm" ] && _RUBY_RVM_AVAILABLE=true


        if $_RUBY_RBENV_AVAILABLE; then
            rbenv_load "$_RUBY_RBENV_ROOT"
            break
        elif $_RUBY_RVM_AVAILABLE; then
            rvm_load "$_RUBY_RVM_ROOT"
            break
        fi
    done
}

ruby_env






is_ruby_file()
{
    for is_ruby_file__ext in $_RUBY_FILE_EXT; do
        case "$1" in
            *.$is_ruby_file__ext) return 0;;
        esac
    done
    return 1
}






















ruby_script_base()
{
    cat <<EOF
#!/usr/bin/env ruby
# -*- mode: ruby -*-

EOF
}








#%require% std.lib
#%require% dev.lib
#%require% terminal.lib
#%require% file.lib








ruby_script_init()
{
    [ $# -ne 1 ] && return 1
    ruby_script_base > "$1"
}

ruby_script_name()
{
    ruby_script_name="$1.rb"
}


ruby_file_tag()
{
    ruby_file_tag=
    case "$1" in
        *_spec.rb) ruby_file_tag=rspec ;;
        *_test.rb) ruby_file_tag=minitest ;;
        *.rb)      ruby_file_tag=source ;;
        *.gemspec) ruby_file_tag=ruby ;;
    esac
}

ruby_guard()
{
    file_mon -c 'ruby_rgr "%s"' "$@"
}

ruby_rubocop()
{
    which rubocop 2>/dev/null >/dev/null || return 0
    rubocop -f fu -R "$1"
}

ruby_reek()
{
    which reek 2>/dev/null >/dev/null || return 0
    reek "$1"
}

ruby_gemfile_env()
{
    ruby_gemfile_env=
    [ -r 'Gemfile' ] || return 1
    ruby_gemfile_env='bundle exec'
}

ruby_rake_env()
{
    ruby_rake_env=
    [ -r 'Rakefile' ] || return 1
    ruby_rake_env=rake
}

ruby_rspec()
{
    ruby_gemfile_env
    $ruby_gemfile_env rspec "$1"
}

ruby_rspec_all()
{
    ruby_gemfile_env
    $ruby_gemfile_env rspec
}

ruby_minitest()
{
    ruby_gemfile_env
    ruby_rake_env

    ruby_minitest__rake="${ruby_rake_env:+$ruby_rake_env test}"
    ruby_minitest__cmd="${ruby_minitest__rake:-ruby}"
    ruby_minitest__arg="${ruby_rake_env:+TEST=}"
    ruby_minitest__arg="${ruby_minitest__arg}$1"

    $ruby_gemfile_env $ruby_minitest__cmd $ruby_minitest__arg
}

ruby_minitest_all()
{
    ruby_gemfile_env
    ruby_rake_env

    [ -z "$ruby_rake_env" ] && return 0

    $ruby_gemfile_env $ruby_rake_env test
}

ruby_rgr()
{
    [ -r "$1" ] || return 1

    ruby_rgr__verbose=true
    if [ "$1" = '-q' ]; then
        shift
        ruby_rgr__verbose=false
    fi
    ruby_file_tag "${1}"
    [ -z "$ruby_file_tag" ] && return 1
    ruby_rgr__status=0
    ruby_rgr__file="${1#\./}"

    $ruby_rgr__verbose && \
        ruby_rgr_title "$ruby_rgr__file changed: $ruby_file_tag / `date '+%Y-%m-%d %H:%M:%S'`"

    ruby_rgr_test "$ruby_rgr__file" "$ruby_file_tag" && \
        ruby_rgr_rubocop "$ruby_rgr__file" && \
        ruby_rgr_reek "$ruby_rgr__file" && \
        ruby_rgr_stage "$ruby_rgr__file" || \
            ruby_rgr__status=1

    if [ $ruby_rgr__status -eq 0 ]; then
        ruby_rgr__status_msg=OK
    else
        ruby_rgr__status_msg=FAILED
    fi

    $ruby_rgr__verbose && \
        ruby_rgr_title "$ruby_rgr__file end: $ruby_rgr__status_msg / `date '+%Y-%m-%d %H:%M:%S'`"

    return $ruby_rgr__status
}

ruby_rgr_test()
{
    case "$2" in
        source|rspec|minitest) ;;
        *) return 0 ;;
    esac

    if [ "$2" = 'source' ]; then
        ruby_test_find "$1"
        ruby_rgr_test__file="$ruby_test_find__file"
        ruby_rgr_test__type="$ruby_test_find__type"
    else
        ruby_rgr_test__file="$1"
        ruby_rgr_test__type="$2"
    fi

    if [ -z "$ruby_rgr_test__file" ]; then
        $ruby_rgr__verbose && \
            ruby_rgr_subtitle "test not found for $2 $1"
        return 1
    fi

    ruby_rgr_test_one "${ruby_rgr_test__type}" "$ruby_rgr_test__file" && \
        ruby_rgr_test_all "${ruby_rgr_test__type}"
}

ruby_rgr_test_one()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "test : $2($1)"
    ruby_${ruby_rgr_test__type} "$ruby_rgr_test__file"
}

ruby_rgr_test_all()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "test : all($1)"
    ruby_${ruby_rgr_test__type}_all
}

ruby_rgr_rubocop()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "rubocop : $1"
    ruby_rubocop "$1"
}

ruby_rgr_reek()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "reek : $1"
    ruby_reek "$1"
}

ruby_rgr_stage()
{
    $ruby_rgr__verbose && \
        ruby_rgr_subtitle "git stage : $1"
    git_scm_add "$1"
}

ruby_rgr_title()
{
    terminal_set_attr 0  $TERMINAL_BOLD
    #terminal_set_fg $TERMINAL_CYAN
    terminal_set_fg $TERMINAL_YELLOW
    printf "|>>> %s <<<|\n" "$@"
    terminal_set_fg ''
}

ruby_rgr_subtitle()
{
    terminal_set_attr 0  $TERMINAL_BOLD
    #terminal_set_fg $TERMINAL_CYAN
    terminal_set_fg $TERMINAL_YELLOW
    printf "|  > %s <  |\n" "$@"
    terminal_set_fg ''
}

ruby_test_find()
{
    ruby_test_find__file=
    ruby_test_find__type=
    for ruby_test_find__t in $RUBY_TEST_FRAMEWORKS; do
        if ruby_${ruby_test_find__t}_find "$1"; then
            eval ruby_test_find__file=\$ruby_${ruby_test_find__t}_find
            ruby_test_find__type=$ruby_test_find__t
            break
        fi
    done
}

ruby_minitest_find()
{
    ruby_minitest_find="${1%.rb}_test.rb"

    [ -r "${ruby_minitest_find}" ] && return 0

    ruby_minitest_find="test/${ruby_minitest_find#*/}"
    [ -r "$ruby_minitest_find" ]
}

ruby_rspec_find()
{
    ruby_rspec_find="${1%.rb}_spec.rb"

    [ -r "${ruby_rspec_find}" ] && return 0

    ruby_rspec_find="spec/${ruby_rspec_find#*/}"
    [ -r "$ruby_rspec_find" ]
}

ruby_gem_install()
{
    for ruby_gem_install__g in $RUBY_QUALITY_GEMS; do
        terminal_set_fg $TERMINAL_YELLOW
        echo gem install $ruby_gem_install__g
        terminal_set_fg ''
        gem install -q $ruby_gem_install__g
    done
}


###############################################################################
# init suite
###############################################################################

ruby_init_list()
{
    echo 'ruby_init actions are :'
    grep '^ruby_init_[a-z_]*()' "$TOOLSH_FILE" | \
        while read ruby_init_list__action; do
            ruby_init_list__action="${ruby_init_list__action#ruby_init_}"
            ruby_init_list__action="${ruby_init_list__action%()}"
            printf " %s\n" "$ruby_init_list__action"
        done
}

ruby_init()
{
    if [ -z "$1" ]; then
        ruby_init_list
        return 0
    fi
    ruby_init="$1" ; shift
    ruby_init_"${ruby_init}" "$@"
}

ruby_init_kata()
{
    ruby_init_kata_gemfile "$@"   || return 1
    ruby_init_kata_rakefile "$@"  || return 1
    ruby_init_kata_guardfile "$@" || return 1
    ruby_init_gitignore "$@" || return 1
}

_ruby_init_opts()
{
    _ruby_init_opts=
    _ruby_init_opts__force=FALSE

    OPTIND=1
    while getopts :f _ruby_init_opts__opt; do
        case $_ruby_init_opts__opt in
            f) _ruby_init_opts="${_ruby_init_opts} -f"
               _ruby_init_opts__force=TRUE ;;
        esac
    done
    _ruby_init_opts__index=$(($OPTIND - 1))
}

_ruby_init_cd()
{
    _ruby_init_cd="${1:-.}"
    cd "$_ruby_init_cd" || return 1
    _ruby_init_cd="$PWD"
    if [ -d "ruby" ]; then
        cd "ruby" || return 1
        _ruby_init_cd="$_ruby_init_cd/ruby/"
    fi
}

_ruby_init_copy()
{
    [ -z "$1" ] && return 1
    [ -z "$2" ] && return 1

    if [ -r "$2" ]; then
        echo "Diff from $2 to $1"
        diff "$2" "$1"
        echo
    fi

    cp "$1" "$2" || return 1
    if git_is_inside_work_tree; then
        git add "$2"
    fi
}

ruby_init_kata_gemfile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/Gemfile_kata" \
                    'Gemfile'

    bundle || return 1
)

ruby_init_kata_rakefile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/Rakefile_kata" \
                    'Rakefile'
)

ruby_init_kata_guardfile()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    ruby_init_kata_guardfile__source=
    if [ -d 'spec' ] || [ -d 'test' ]; then
        [ -d 'test' ] &&
            ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_test"
        [ -d 'spec' ] &&
            ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_spec"
    else
        ruby_init_kata_guardfile__source="$TOOLSH_DIR/../templates/ruby/Guardfile_test"
    fi

    _ruby_init_copy "$ruby_init_kata_guardfile__source" \
                    'Guardfile'
)

ruby_init_gitignore()
(
    _ruby_init_opts "$@" ; shift "$_ruby_init_opts__index"

    _ruby_init_cd "$@" || return 1

    _ruby_init_copy "$TOOLSH_DIR/../templates/ruby/gitignore_ruby" \
                    '.gitignore'
)
